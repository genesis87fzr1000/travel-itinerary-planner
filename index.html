<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—…ç¨‹ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼ (v2.1)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ« */
        .draggable-item { cursor: grab; transition: all 0.2s; }
        .dragging { opacity: 0.5; transform: scale(1.02); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .drag-handle { cursor: move; }

        .nav-button.active {
            background-color: #4f46e5; color: white; border-bottom: 4px solid #6366f1;
        }
        .nav-button:not(.active) {
            background-color: #f9fafb; color: #1f2937;
        }
        
        /* ã—ãŠã‚Šç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .shiori-row {
            display: flex;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        .shiori-num {
            flex-shrink: 0;
            width: 50px;
            font-weight: 800;
            color: #4f46e5; /* Indigo-600 */
        }
        .shiori-content {
            flex-grow: 1;
            font-weight: 600;
            color: #1f2937;
        }
        /* æŠ˜ã‚ŠãŸãŸã¿ç”¨åœ°å›³ã‚³ãƒ³ãƒ†ãƒŠ */
        .map-container {
            transition: max-height 0.3s ease-out;
            max-height: 0;
            overflow: hidden;
        }
        .map-container.open {
            max-height: 400px;
        }
    </style>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAOStiNglNEGEnPnhDxJG0RSQqgJXVtUQw&libraries=places,geometry&callback=initMap" async defer></script>
    
    </head>
<body class="bg-gray-100 min-h-screen p-2 sm:p-6 text-gray-800">

    <div class="max-w-4xl mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden">
        
        <header class="p-6 bg-indigo-700 text-white shadow-xl flex justify-between items-center">
            <h1 class="text-2xl sm:text-3xl font-extrabold flex items-center gap-2">
                <span>ğŸ—ºï¸</span> æ—…ç¨‹ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼
                <span class="text-xs bg-indigo-500 px-2 py-1 rounded-full uppercase tracking-wider">v2.1</span>
            </h1>
            <button onclick="clearData()" class="text-xs text-indigo-200 hover:text-white underline">ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–</button>
        </header>

        <nav class="flex border-b border-gray-200 bg-gray-50 text-sm sm:text-base">
            <button onclick="navigate('input')" id="nav-input" class="nav-button flex-1 py-4 font-bold transition-colors">1. åœ°ç‚¹ãƒ»åŸºç‚¹</button>
            <button onclick="navigate('selection')" id="nav-selection" class="nav-button flex-1 py-4 font-bold transition-colors">2. ãƒ«ãƒ¼ãƒˆé¸æŠ</button>
            <button onclick="navigate('shiori')" id="nav-shiori" class="nav-button flex-1 py-4 font-bold transition-colors">3. æ—…ã®ã—ãŠã‚Š</button>
        </nav>

        <main id="app-content" class="p-4 sm:p-8 min-h-[500px]">
            </main>

        <div id="message-container" class="fixed bottom-4 right-4 z-50 w-full max-w-sm px-4"></div>
    </div>

    <datalist id="saved-locations-list"></datalist>

    <script>
        // ===============================================
        // 1. çŠ¶æ…‹ç®¡ç† (State & Logic)
        // ===============================================
        const APP_VERSION = '2.2'; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’2.2ã«æ›´æ–°

        // â˜…â˜…â˜… ã“ã“ãŒä¸€ç•ªæœ€åˆã§ã‚ã‚‹ã¹ã
        function initMap() {
            console.log("Google Maps API Loaded successfully.");
        }
    
        const generateDefaultItinerary = () => ({
            version: APP_VERSION,
            planName: "æ–°è¦æ—…ç¨‹ãƒ—ãƒ©ãƒ³ " + new Date().toLocaleDateString('ja-JP'),
            baseDateTime: new Date().toISOString().substring(0, 16),
            roundingMinutes: 0,
            gatheringMinutes: 10,
            stops: [
                { id: 's-start', location: 'æ±äº¬é§…', isBaseTime: true, isFixed: true, stayMinutes: 0, stayReason: '', memo: '' },
                { id: 's-way1', location: 'æ¸‹è°·é§…', isBaseTime: false, isFixed: false, stayMinutes: 15, stayReason: 'Bç­å¾…ã¡åˆã‚ã›', memo: '' },
                { id: 's-way2', location: 'ã‚‰ã‚‰ã½ãƒ¼ã¨æ¨ªæµœ', isBaseTime: false, isFixed: false, stayMinutes: 60, stayReason: 'æ˜¼é£Ÿ', memo: 'ã€‡ã€‡ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³äºˆç´„æ¸ˆã¿' },
                { id: 's-end', location: 'æ¨ªæµœé§…', isBaseTime: false, isFixed: true, stayMinutes: 0, stayReason: '', memo: '' }
            ],
            segments: [], 
            currentPage: 'input'
        });

        // ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        function loadState() {
            try {
                const saved = JSON.parse(localStorage.getItem('itineraryState'));
                // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒé•ã†ã€ã¾ãŸã¯ãƒ‡ãƒ¼ã‚¿ãŒå£Šã‚Œã¦ã„ã‚‹å ´åˆã¯åˆæœŸåŒ–
                if (!saved || saved.version !== APP_VERSION) {
                    console.log("ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒç•°ãªã‚‹ãŸã‚ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ");
                    return generateDefaultItinerary();
                }
                return saved;
            } catch (e) {
                return generateDefaultItinerary();
            }
        }

        let itinerary = loadState();
        let savedLocations = JSON.parse(localStorage.getItem('savedLocations')) || ['æ±äº¬é§…', 'æ–°å®¿é§…', 'æ¨ªæµœä¸­è¯è¡—'];
        let dragState = { draggedId: null };

        // çŠ¶æ…‹ä¿å­˜
        function saveState() {
            itinerary.version = APP_VERSION;
            localStorage.setItem('itineraryState', JSON.stringify(itinerary));
            localStorage.setItem('savedLocations', JSON.stringify(savedLocations));
            updateDatalist();
        }
        
        function updateDatalist() {
            const datalist = document.getElementById('saved-locations-list');
            datalist.innerHTML = savedLocations.map(loc => `<option value="${loc}">`).join('');
        }

        function clearData() {
            if(confirm('å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ')) {
                localStorage.removeItem('itineraryState');
                location.reload();
            }
        }

        // ===============================================
        // 2. æ™‚é–“è¨ˆç®— & APIãƒ¢ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯
        // ===============================================

        function addMinutesToISO(isoString, minutes) {
            const date = new Date(isoString);
            date.setMinutes(date.getMinutes() + minutes);
            const tzOffset = date.getTimezoneOffset() * 60000; 
            return (new Date(date - tzOffset)).toISOString().slice(0, 16);
        }

        function formatDisplayTime(isoString) {
            if (!isoString) return "--:--";
            const date = new Date(isoString);
            return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}åˆ†`;
        }

        function roundMinutes(minutes, rounding) {
            if (!rounding || rounding === 0) return minutes;
            const remainder = minutes % rounding;
            return remainder === 0 ? minutes : minutes + (rounding - remainder);
        }

        // â˜… APIä»£ã‚ã‚Šã®ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ (æ–™é‡‘æƒ…å ±ã‚’è©³ç´°åŒ–)
        function getMockRoutes(from, to, mode) {
            const baseTime = 20 + (from.length + to.length) * 2; 
            const multiplier = mode === 'walking' ? 4 : mode === 'bicycling' ? 2 : 1;
            const duration = baseTime * multiplier;
            
            const tolls = [];
            if (mode === 'driving' && Math.random() > 0.3) {
                tolls.push({ name: 'é¦–éƒ½é«˜é€Ÿ', standard: 700, kei: 500 });
                if (Math.random() > 0.5) {
                    tolls.push({ name: 'æ±åé«˜é€Ÿ', standard: 800, kei: 600 });
                }
            }

            return [
                { id: 'r1', label: 'æ¨å¥¨', durationMinutes: duration, tolls: tolls, desc: 'ãƒãƒ©ãƒ³ã‚¹å‹' },
                { id: 'r2', label: 'æœ€çŸ­', durationMinutes: Math.max(5, duration - 10), tolls: [...tolls, {name:'è¿½åŠ åŒºé–“', standard:300, kei:200}], desc: 'æ€¥ãã®å ´åˆ' },
                { id: 'r3', label: 'å®‰ä¾¡', durationMinutes: duration + 20, tolls: [], desc: 'ä¸‹é“å„ªå…ˆ' }
            ];
        }

        // â˜…â˜…â˜… Directions APIã‚’ä½¿ã£ãŸå®Ÿéš›ã®ãƒ«ãƒ¼ãƒˆè¨ˆç®— (æ–°è¦è¿½åŠ )
        function getRealRoutes(fromStop, toStop, segIndex, mode) {
            const directionsService = new google.maps.DirectionsService();

            return new Promise((resolve, reject) => {
                directionsService.route(
                    {
                        origin: fromStop.location,
                        destination: toStop.location,
                        travelMode: mode.toUpperCase(), // 'driving', 'walking', 'bicycling'
                        provideRouteAlternatives: true // è¤‡æ•°ã®ãƒ«ãƒ¼ãƒˆå€™è£œã‚’å–å¾—
                    },
                    (response, status) => {
                        if (status === google.maps.DirectionsStatus.OK) {
                            const newRoutes = response.routes.slice(0, 3).map((route, i) => {
                                // ãƒ«ãƒ¼ãƒˆã”ã¨ã®æƒ…å ±ã‚’æŠ½å‡º
                                const leg = route.legs[0];
                                const durationMinutes = Math.ceil(leg.duration.value / 60);
                                
                                // æœ‰æ–™é“è·¯æƒ…å ± (ç°¡æ˜“çš„ãªãƒ¢ãƒƒã‚¯ã‚’ä½µç”¨)
                                const tolls = [];
                                if (route.fare && route.fare.value > 0) {
                                    tolls.push({ 
                                        name: 'æ¨å®šæ–™é‡‘', 
                                        standard: Math.ceil(route.fare.value), 
                                        kei: Math.ceil(route.fare.value * 0.8) 
                                    });
                                } else if (mode === 'driving' && route.warnings.some(w => w.includes('toll'))) {
                                    // Directions APIãŒç›´æ¥æ–™é‡‘ã‚’è¿”ã•ãªã„å ´åˆã®è­¦å‘Šã‚’æ–™é‡‘ã¨è¦‹ãªã™
                                     tolls.push({ name: 'æœ‰æ–™åŒºé–“ã‚ã‚Š', standard: 1000, kei: 700 });
                                }

                                return {
                                    id: `r${i + 1}`,
                                    label: `å€™è£œ ${i + 1}`,
                                    durationMinutes: durationMinutes,
                                    tolls: tolls,
                                    desc: route.summary || 'æœ€é©ãªãƒ«ãƒ¼ãƒˆ'
                                };
                            });

                            itinerary.segments[segIndex].mockRoutes = newRoutes;
                            itinerary.segments[segIndex].selectedRoute = newRoutes.length > 0 ? newRoutes[0].id : null;
                            resolve();

                        } else {
                            itinerary.segments[segIndex].mockRoutes = [];
                            itinerary.segments[segIndex].selectedRoute = null;
                            reject(`Google Directions Status: ${status}`);
                        }
                    }
                );
            });
        }

        // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨ˆç®—
        function calculateAllSchedule() {
            const baseIndex = itinerary.stops.findIndex(s => s.isBaseTime);
            if (baseIndex === -1) return false;

            // Forward
            let currentTime = itinerary.baseDateTime;
            for (let i = baseIndex; i < itinerary.stops.length; i++) {
                const stop = itinerary.stops[i];
                stop.arrivalTime = currentTime;
                const roundedStay = roundMinutes(stop.stayMinutes, itinerary.roundingMinutes);
                stop.departureTime = addMinutesToISO(stop.arrivalTime, roundedStay);

                if (i < itinerary.stops.length - 1) {
                    if (!itinerary.segments[i]) initSegment(i);
                    const seg = itinerary.segments[i];
                    let duration = 30;
                    if (seg.mockRoutes && seg.mockRoutes.length > 0) {
                        const route = seg.selectedRoute ? seg.mockRoutes.find(r => r.id === seg.selectedRoute) : seg.mockRoutes[0];
                        duration = route ? route.durationMinutes : 30;
                        if (!seg.selectedRoute) seg.selectedRoute = route.id;
                    }
                    currentTime = addMinutesToISO(stop.departureTime, duration);
                }
            }

            // Backward
            currentTime = itinerary.stops[baseIndex].arrivalTime; 
            for (let i = baseIndex - 1; i >= 0; i--) {
                const nextStop = itinerary.stops[i+1];
                const seg = itinerary.segments[i];
                if (!seg) initSegment(i);

                let duration = 30;
                if (seg.mockRoutes && seg.mockRoutes.length > 0) {
                    const route = seg.selectedRoute ? seg.mockRoutes.find(r => r.id === seg.selectedRoute) : seg.mockRoutes[0];
                    duration = route ? route.durationMinutes : 30;
                    if (!seg.selectedRoute) seg.selectedRoute = route.id;
                }

                const currentDeparture = addMinutesToISO(nextStop.arrivalTime, -duration);
                itinerary.stops[i].departureTime = currentDeparture;
                const roundedStay = roundMinutes(itinerary.stops[i].stayMinutes, itinerary.roundingMinutes);
                itinerary.stops[i].arrivalTime = addMinutesToISO(currentDeparture, -roundedStay);
            }
            return true;
        }

        function initSegment(index) {
            itinerary.segments[index] = {
                fromStopId: itinerary.stops[index].id,
                toStopId: itinerary.stops[index+1].id,
                travelMode: 'driving', // default
                selectedRoute: null,
                mockRoutes: getMockRoutes(itinerary.stops[index].location, itinerary.stops[index+1].location, 'driving')
            };
        }

        // ===============================================
        // 3. UIãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° (Pages)
        // ===============================================

        function navigate(pageId) {
            try {
                if (pageId === 'selection' || pageId === 'shiori') {
                    const success = calculateAllSchedule();
                    if (!success && itinerary.stops.findIndex(s => s.isBaseTime) === -1) {
                        showAlert('åŸºç‚¹ã¨ãªã‚‹æ—¥æ™‚ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                        return;
                    }
                }
                itinerary.currentPage = pageId;
                updateNavStyles(pageId);
                
                const content = document.getElementById('app-content');
                if (pageId === 'input') renderInputPage(content);
                else if (pageId === 'selection') renderSelectionPage(content);
                else if (pageId === 'shiori') renderShioriPage(content);
                
                saveState();
            } catch (e) {
                console.error(e);
                showAlert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å³ä¸Šã®ã€Œãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–ã€ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚', 'error');
            }
        }

        function updateNavStyles(activePage) {
            document.querySelectorAll('.nav-button').forEach(btn => {
                if (btn.dataset.page === activePage || btn.id === `nav-${activePage}`) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // --- Page 1: å…¥åŠ›ç”»é¢ ---
        function renderInputPage(container) {
            if (itinerary.segments.length < itinerary.stops.length - 1) {
                itinerary.segments = new Array(itinerary.stops.length - 1).fill(null);
            }

            const gatheringOptions = [
                {v:5, l:'5åˆ†å‰'}, {v:10, l:'10åˆ†å‰'}, {v:20, l:'20åˆ†å‰'}, 
                {v:30, l:'30åˆ†å‰'}, {v:40, l:'40åˆ†å‰'}, {v:50, l:'50åˆ†å‰'}, {v:60, l:'60åˆ†å‰'}
            ];

            container.innerHTML = `
                <div class="space-y-6 animate-fade-in">
                    <div class="p-5 bg-indigo-50 rounded-xl border border-indigo-100 grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">åŸºç‚¹æ—¥æ™‚ (Start/Target)</label>
                            <input type="datetime-local" value="${itinerary.baseDateTime}" 
                                onchange="itinerary.baseDateTime=this.value; saveState();"
                                class="w-full p-2 border rounded shadow-sm focus:ring-2 focus:ring-indigo-500 font-bold">
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">ãƒãƒƒãƒ•ã‚¡ (Rounding)</label>
                            <select onchange="itinerary.roundingMinutes=parseInt(this.value); saveState();" class="w-full p-2 border rounded shadow-sm font-bold">
                                <option value="0" ${itinerary.roundingMinutes===0?'selected':''}>ãªã— (1åˆ†å˜ä½)</option>
                                <option value="5" ${itinerary.roundingMinutes===5?'selected':''}>5åˆ†å˜ä½</option>
                                <option value="10" ${itinerary.roundingMinutes===10?'selected':''}>10åˆ†å˜ä½</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">é›†åˆæ™‚é–“è¨­å®š</label>
                            <select onchange="itinerary.gatheringMinutes=parseInt(this.value); saveState();" class="w-full p-2 border rounded shadow-sm font-bold">
                                ${gatheringOptions.map(o => `<option value="${o.v}" ${itinerary.gatheringMinutes===o.v?'selected':''}>${o.l}</option>`).join('')}
                            </select>
                        </div>
                    </div>

                    <div id="sortable-list" class="space-y-6">
                        ${itinerary.stops.map((stop, i) => renderStopCard(stop, i)).join('')}
                    </div>

                    <button onclick="addStop()" class="w-full py-3 bg-white border-2 border-dashed border-gray-300 text-gray-500 font-bold rounded-xl hover:border-indigo-500 hover:text-indigo-500 transition">
                        + çµŒç”±åœ°ã‚’è¿½åŠ 
                    </button>
                    
                    <div class="h-4"></div>
                    <button onclick="navigate('selection')" class="w-full py-4 bg-indigo-600 text-white font-bold text-xl rounded-xl shadow-lg hover:bg-indigo-700 transition">
                        æ¬¡ã¸ï¼šãƒ«ãƒ¼ãƒˆè¨ˆç®— ğŸš€
                    </button>
                </div>
            `;
            setupDragAndDrop();
        }

        function renderStopCard(stop, index) {
            const isFirst = index === 0;
            const isLast = index === itinerary.stops.length - 1;
            
            return `
            <div class="draggable-item bg-white p-5 rounded-xl shadow-sm border border-gray-200 relative ${stop.isBaseTime ? 'ring-2 ring-green-500' : ''}" 
                 data-id="${stop.id}" draggable="${!stop.isFixed}" data-fixed="${stop.isFixed}">
                
                <div class="flex items-start justify-between mb-4">
                    <div class="flex items-center gap-2">
                        <span class="bg-gray-800 text-white text-xs font-bold px-2 py-1 rounded">${index + 1}</span>
                        <span class="font-bold text-lg text-gray-700">${isFirst ? 'å‡ºç™ºåœ°' : isLast ? 'ç›®çš„åœ°' : 'çµŒç”±åœ°'}</span>
                        ${stop.isBaseTime ? '<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full font-bold">ã“ã“ãŒæ™‚é–“ã®åŸºæº–</span>' : ''}
                    </div>
                    <div class="flex items-center gap-2">
                        ${!stop.isFixed ? `<div class="drag-handle text-gray-400 cursor-move" title="ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•">â˜°</div>` : ''}
                        ${!stop.isFixed ? `<button onclick="removeStop('${stop.id}')" class="text-gray-400 hover:text-red-500">ğŸ—‘ï¸</button>` : ''}
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-xs font-bold text-gray-400 mb-1">åœ°ç‚¹åå…¥åŠ› (æ–½è¨­å/ä½æ‰€)</label>
                    <div class="flex gap-2">
                        <input type="text" list="saved-locations-list" value="${stop.location}" onchange="updateLocation('${stop.id}', this.value)" 
                               class="flex-1 p-2 border rounded focus:ring-2 focus:ring-indigo-500 font-bold" placeholder="ä¾‹: æ±äº¬ã‚¿ãƒ¯ãƒ¼">
                        <button onclick="saveLocation('${stop.id}')" class="bg-gray-100 hover:bg-gray-200 text-gray-600 px-3 py-2 rounded text-sm font-bold" title="åœ°åã‚’ä¿å­˜">ğŸ’¾</button>
                        <button onclick="validateLocation('${stop.id}')" class="bg-blue-50 hover:bg-blue-100 text-blue-600 px-3 py-2 rounded text-sm font-bold" title="GoogleMapã§å­˜åœ¨ç¢ºèª">ğŸ” æ¤œè¨¼</button>
                    </div>
                </div>

                ${!isFirst && !isLast ? `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-xs font-bold text-gray-400 mb-1">æ»åœ¨æ™‚é–“è¨­å®š (åˆ†)</label>
                        <input type="number" value="${stop.stayMinutes}" onchange="updateStay('${stop.id}', this.value)" 
                               class="w-full p-2 border rounded text-center font-bold" placeholder="åˆ†">
                    </div>
                    <div>
                        <label class="block text-xs font-bold text-gray-400 mb-1">æ»åœ¨ç†ç”±</label>
                        <input type="text" value="${stop.stayReason}" onchange="updateReason('${stop.id}', this.value)" 
                               class="w-full p-2 border rounded" placeholder="ä¾‹: æ˜¼é£Ÿ">
                    </div>
                </div>
                ` : ''}

                <div class="mb-4">
                    <label class="block text-xs font-bold text-gray-400 mb-1">ãƒ¡ãƒ¢ (ã—ãŠã‚Šã«è¡¨ç¤º)</label>
                    <input type="text" value="${stop.memo || ''}" onchange="updateMemo('${stop.id}', this.value)" 
                           class="w-full p-2 border rounded bg-yellow-50 focus:bg-white transition" placeholder="ä¾‹: ã€‡ã€‡ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³äºˆç´„æ¸ˆã¿">
                </div>

                <div class="flex items-center gap-2 text-sm text-gray-600 mb-4 pb-4 border-b border-gray-100">
                    <label class="flex items-center gap-2 cursor-pointer hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="baseTimeGroup" ${stop.isBaseTime ? 'checked' : ''} 
                               onchange="setBaseTimeStop('${stop.id}')" class="text-indigo-600">
                        <span>ã“ã®æ™‚é–“ã‚’å›ºå®š(åŸºç‚¹)ã«ã™ã‚‹</span>
                    </label>
                </div>

                ${!isLast ? renderTravelModeSelection(index) : ''}
            </div>`;
        }

        function renderTravelModeSelection(index) {
            if (!itinerary.segments[index]) initSegment(index);
            const seg = itinerary.segments[index];
            const modes = [
                { id: 'driving', icon: 'ğŸš—', label: 'è»Šç§»å‹•' },
                { id: 'walking', icon: 'ğŸš¶', label: 'å¾’æ­©ç§»å‹•' },
                { id: 'bicycling', icon: 'ğŸš´', label: 'è‡ªè»¢è»Šç§»å‹•' }
            ];

            return `
            <div>
                <label class="block text-xs font-bold text-gray-400 mb-1 text-center">æ¬¡ã®åœ°ç‚¹ã¸ã®ç§»å‹•æ‰‹æ®µ</label>
                <div class="flex justify-center gap-2">
                    ${modes.map(m => `
                        <button onclick="updateMode(${index}, '${m.id}')" 
                                class="flex items-center gap-1 px-3 py-2 rounded border text-sm transition-colors
                                ${seg.travelMode === m.id ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold' : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50'}">
                            ${m.icon} ${m.label}
                        </button>
                    `).join('')}
                </div>
            </div>`;
        }

        // --- Page 2: ãƒ«ãƒ¼ãƒˆé¸æŠç”»é¢ ---
        function renderSelectionPage(container) {
            container.innerHTML = `
                <h2 class="text-xl font-bold mb-4 text-gray-800">çµŒè·¯ã®é¸æŠ</h2>
                <div class="space-y-8">
                    ${itinerary.segments.map((seg, i) => {
                        if (!seg.mockRoutes) seg.mockRoutes = getMockRoutes(itinerary.stops[i].location, itinerary.stops[i+1].location, seg.travelMode);
                        
                        const modeLabel = seg.travelMode === 'driving' ? 'è»Š' : seg.travelMode === 'walking' ? 'å¾’æ­©' : 'è‡ªè»¢è»Š';
                        const modeIcon = seg.travelMode === 'driving' ? 'ğŸš—' : seg.travelMode === 'walking' ? 'ğŸš¶' : 'ğŸš´';

                        return `
                        <div class="bg-white p-5 rounded-xl shadow-md border border-gray-200">
                            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-100">
                                <div class="text-sm font-bold text-gray-600 flex items-center gap-2">
                                    <span class="bg-indigo-600 text-white px-2 py-1 rounded">åŒºé–“ ${i+1}</span>
                                    <span>${itinerary.stops[i].location}</span>
                                    <span>â†’</span>
                                    <span>${itinerary.stops[i+1].location}</span>
                                </div>
                                <div class="text-sm font-bold text-indigo-600 bg-indigo-50 px-2 py-1 rounded border border-indigo-100">
                                    ${modeIcon} ${modeLabel}
                                </div>
                            </div>

                            <div class="space-y-2 mb-4">
                                ${seg.mockRoutes.map(route => `
                                    <label class="flex items-center justify-between p-3 border rounded-lg cursor-pointer hover:bg-indigo-50 transition ${seg.selectedRoute === route.id ? 'border-indigo-500 ring-1 ring-indigo-500 bg-indigo-50' : ''}">
                                        <div class="flex items-center gap-3">
                                            <input type="radio" name="route-seg-${i}" value="${route.id}" 
                                                   ${seg.selectedRoute === route.id ? 'checked' : ''} 
                                                   onchange="selectRoute(${i}, '${route.id}')" class="text-indigo-600">
                                            <div>
                                                <div class="font-bold text-gray-800">${route.label} <span class="text-xs font-normal text-gray-500">(${route.desc})</span></div>
                                                <div class="text-xs text-gray-500">
                                                    ${(route.tolls || []).length > 0 ? `<span class="text-red-500">æœ‰æ–™: ${(route.tolls || []).length}åŒºé–“</span>` : 'ç„¡æ–™'}
                                                </div>
                                            </div>
                                        </div>
                                        <div class="text-lg font-bold text-gray-700">${route.durationMinutes}åˆ†</div>
                                    </label>
                                `).join('')}
                            </div>
                            
                            <div class="border border-gray-200 rounded-lg overflow-hidden">
                                <button onclick="toggleMap('map-${i}')" class="w-full bg-gray-50 p-2 text-xs font-bold text-gray-500 hover:bg-gray-100 flex justify-center items-center gap-1">
                                    ğŸ—ºï¸ åœ°å›³ã‚’è¡¨ç¤º/éè¡¨ç¤º (å€™è£œãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤ºäºˆå®š)
                                </button>
                                <div id="map-${i}" class="map-container bg-gray-200 flex items-center justify-center text-gray-400 font-bold">
                                    <div class="p-10">Google Map Placeholder<br>(APIé€£æºæ™‚ã«ã“ã“ã«ãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤º)</div>
                                </div>
                            </div>
                        </div>
                        `;
                    }).join('')}
                </div>
                <div class="h-8"></div>
                <button onclick="navigate('shiori')" class="w-full py-4 bg-green-600 text-white font-bold text-xl rounded-xl shadow-lg hover:bg-green-700 transition">
                    æ—…ã®ã—ãŠã‚Šã‚’ä½œæˆã™ã‚‹ âœ¨
                </button>
            `;
        }

        function toggleMap(id) {
            const el = document.getElementById(id);
            el.classList.toggle('open');
        }

        // --- Page 3: æ—…ã®ã—ãŠã‚Š (ç¢ºå®šç”»é¢) ---
        function renderShioriPage(container) {
            calculateAllSchedule();

            const events = [];
            let eventCounter = 1;

            itinerary.stops.forEach((stop, i) => {
                const isFirst = (i === 0);
                const isLast = (i === itinerary.stops.length - 1);
                
                if (isFirst) {
                    const gatherTime = addMinutesToISO(stop.departureTime, -itinerary.gatheringMinutes);
                    events.push({
                        idx: eventCounter++,
                        text: `${stop.location}ã€€${formatDisplayTime(gatherTime)}ã€€é›†åˆ`
                    });
                    
                    events.push({
                        idx: eventCounter++,
                        text: `${stop.location}ã€€${formatDisplayTime(stop.departureTime)}ã€€å‡ºç™º`
                    });
                } else {
                    events.push({
                        idx: eventCounter++,
                        text: `${stop.location}ã€€${formatDisplayTime(stop.arrivalTime)}ã€€åˆ°ç€`
                    });

                    if (!isLast) {
                        const memoText = stop.memo ? `ã€€${stop.memo}` : '';
                        events.push({
                            idx: eventCounter++,
                            text: `${stop.location}ã€€${stop.stayReason || 'æ»åœ¨'}ã€€ï¼ˆæ»åœ¨æ™‚é–“ã€€${stop.stayMinutes}åˆ†ï¼‰${memoText}`
                        });
                        
                        events.push({
                            idx: eventCounter++,
                            text: `${stop.location}ã€€${formatDisplayTime(stop.departureTime)}ã€€å‡ºç™º`
                        });
                    }
                }

                if (!isLast) {
                    const seg = itinerary.segments[i];
                    const route = seg.selectedRoute ? seg.mockRoutes.find(r => r.id === seg.selectedRoute) : seg.mockRoutes[0];
                    const duration = route ? route.durationMinutes : 30;
                    
                    const modeText = seg.travelMode === 'driving' ? 'è»Šç§»å‹•' : seg.travelMode === 'walking' ? 'å¾’æ­©ç§»å‹•' : 'è‡ªè»¢è»Šç§»å‹•';
                    
                    let costText = '';
                    const tolls = route ? (route.tolls || []) : [];
                    if (tolls.length > 0) {
                        const tollsStr = tolls.map((t, idx) => {
                            const prefix = tolls.length > 1 ? `æ–™é‡‘${idx+1}` : 'æ–™é‡‘';
                            const name = t.name ? `â†’${tolls.length > 1 ? 'â‘ ':''}${t.name}` : ''; 
                            return `${prefix}${name}ã€€${t.standard}å††ï¼ˆè»½${t.kei}å††ï¼‰`;
                        }).join('ã€€');
                        costText = `ã€€æœ‰æ–™é“è·¯${tollsStr}`;
                    }

                    events.push({
                        idx: eventCounter++,
                        text: `${modeText}ã€€${duration}åˆ†${costText}`
                    });
                }
            });

            const rowsHtml = events.map(e => `
                <div class="shiori-row">
                    <div class="shiori-num">${e.idx.toString().padStart(2, '0')}.</div>
                    <div class="shiori-content">${e.text}</div>
                </div>
            `).join('');

            container.innerHTML = `
                <div class="bg-white p-8 rounded-xl shadow-lg border border-gray-100 max-w-3xl mx-auto">
                    <h2 class="text-3xl font-extrabold text-center mb-2 text-indigo-900">${itinerary.planName}</h2>
                    <p class="text-center text-gray-500 text-sm mb-10 border-b pb-4">æ—…ã®ã—ãŠã‚Š</p>
                    
                    <div class="font-mono text-base md:text-lg leading-relaxed">
                        ${rowsHtml}
                    </div>
                </div>
                
                <div class="h-8"></div>
                <div class="flex gap-4">
                    <button onclick="navigate('input')" class="flex-1 py-3 bg-gray-500 text-white font-bold rounded-xl hover:bg-gray-600 transition">
                        ä¿®æ­£ã«æˆ»ã‚‹
                    </button>
                    <button onclick="window.print()" class="flex-1 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 transition">
                        ğŸ–¨ï¸ å°åˆ· / PDFä¿å­˜
                    </button>
                </div>
            `;
        }

        // ===============================================
        // 4. ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© & ãƒ˜ãƒ«ãƒ‘ãƒ¼
        // ===============================================

        function addStop() {
            const newStop = { 
                id: 's-' + Math.random().toString(36).substr(2, 9), 
                location: '', isBaseTime: false, isFixed: false, stayMinutes: 30, stayReason: '', memo: ''
            };
            itinerary.stops.splice(itinerary.stops.length - 1, 0, newStop);
            itinerary.segments.push(null);
            saveState();
            renderInputPage(document.getElementById('app-content'));
        }

        function removeStop(id) {
            itinerary.stops = itinerary.stops.filter(s => s.id !== id);
            saveState();
            renderInputPage(document.getElementById('app-content'));
        }

        function updateLocation(id, val) { itinerary.stops.find(s => s.id === id).location = val; saveState(); }
        function updateStay(id, val) { itinerary.stops.find(s => s.id === id).stayMinutes = parseInt(val)||0; saveState(); }
        function updateReason(id, val) { itinerary.stops.find(s => s.id === id).stayReason = val; saveState(); }
        function updateMemo(id, val) { itinerary.stops.find(s => s.id === id).memo = val; saveState(); }
        
        function setBaseTimeStop(id) {
            itinerary.stops.forEach(s => s.isBaseTime = (s.id === id));
            saveState();
            renderInputPage(document.getElementById('app-content'));
        }
        function updateMode(index, mode) {
            if(!itinerary.segments[index]) initSegment(index);
            itinerary.segments[index].travelMode = mode;
            
            // ãƒ«ãƒ¼ãƒˆã‚’å†è¨ˆç®—ã—ã€æ–°ã—ã„ãƒ¢ãƒƒã‚¯ãƒ«ãƒ¼ãƒˆã‚’ä¸Šæ›¸ã
            getRealRoutes(itinerary.stops[index], itinerary.stops[index+1], index, mode)
                .then(() => {
                    saveState();
                    renderInputPage(document.getElementById('app-content'));
                })
                .catch(error => {
                    showAlert(`ãƒ«ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: ${error}`, 'error');
                });
        }
        function selectRoute(segIndex, routeId) {
            itinerary.segments[segIndex].selectedRoute = routeId;
            saveState();
            renderSelectionPage(document.getElementById('app-content'));
        }

        function saveLocation(id) {
            const val = itinerary.stops.find(s => s.id === id).location;
            if(val && !savedLocations.includes(val)){
                savedLocations.push(val);
                saveState();
                showAlert(`ã€Œ${val}ã€ã‚’ä¿å­˜ã—ã¾ã—ãŸ`, 'success');
            }
        }
        
        function validateLocation(id) {
            const stop = itinerary.stops.find(s => s.id === id);
            const location = stop.location;
            if(!location) {
                showAlert('åœ°ç‚¹åãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            showAlert(`ã€Œ${location}ã€ã‚’Googleã§æ¤œè¨¼ä¸­...`, 'info');

            // â˜…â˜…â˜… Places API (AutocompleteService) ã‚’åˆ©ç”¨ã—ã¦åœ°ç‚¹ã‚’æ¤œè¨¼
            const service = new google.maps.places.AutocompleteService();
            service.getPlacePredictions({ input: location }, (predictions, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK && predictions.length > 0) {
                    // å€™è£œãŒè¦‹ã¤ã‹ã£ãŸå ´åˆ
                    showAlert(`âœ… OK: ã€Œ${predictions[0].description}ã€ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚`, 'success');
                    // åœ°ç‚¹åãŒè¦‹ã¤ã‹ã£ãŸã‚‚ã®ã«æ›´æ–°
                    stop.location = predictions[0].description;
                    saveState(); 
                    renderInputPage(document.getElementById('app-content'));
                } else {
                    // å€™è£œãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
                    showAlert(`âŒ ã‚¨ãƒ©ãƒ¼: ã€Œ${location}ã€ã¯æ­£ç¢ºã«ç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ä½æ‰€ã‚„æ–½è¨­åã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚`, 'error');
                }
            });
        }

        function showAlert(msg, type='info') {
            const el = document.getElementById('message-container');
            const color = type === 'error' ? 'bg-red-500' : type === 'success' ? 'bg-green-600' : 'bg-indigo-600';
            el.innerHTML = `<div class="${color} text-white px-6 py-3 rounded-full shadow-lg text-center animate-bounce font-bold text-sm">${msg}</div>`;
            setTimeout(() => el.innerHTML = '', 3000);
        }

        function setupDragAndDrop() {
            const list = document.getElementById('sortable-list');
            let draggedItem = null;
            list.addEventListener('dragstart', e => {
                if(e.target.dataset.fixed === 'true') { e.preventDefault(); return; }
                draggedItem = e.target;
                e.target.classList.add('dragging');
            });
            list.addEventListener('dragend', e => {
                e.target.classList.remove('dragging');
                draggedItem = null;
            });
            list.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(list, e.clientY);
                if (afterElement && afterElement.dataset.fixed !== 'true') {
                     list.insertBefore(draggedItem, afterElement);
                }
            });
        }
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        updateDatalist();
        navigate('input');
    </script>
</body>
</html>
